---
title: 区间众数
date: 2017-02-20 15:02:52
categories:
- 笔记
tags:
- 分块
- 众数
---
给定长度为n的序列, 要求支持:
1. 单点修改.
2. 查询某区间的众数, 如有多个, 取最小者 / 查询某区间众数的出现次数.

本文主要是cls <区间众数解题报告> 的学习笔记.

代码实现: [[bzoj 2724] [Violet 6] 蒲公英](/2017/02/20/bzoj2724-dandelion/) 强制在线, 无修改的区间众数.

<!--more-->
# 引理
记可重集$a$的众数为$mode(a)$.
$mode(a \cup b) \in mode(a) \cup b$
否则, $x \in a \cup b$只在$a$中出现, 由于$x \not \in mode(a)$, $x$不是众数.
之所以关注这个引理, 是因为区间众数不具备最优子结构, 但往可重集中加入一个新数, 众数的*变化*是可控的.

# 朴素算法
1. 离散化.
2. 扫描查询的区间, 统计每种数的出现次数.
3. 扫描查询的区间, 找出众数.
4. 扫描查询的区间, 将计数器清零.

每次询问时间$O(n)$.

# 不带修改
## 离线
莫队算法. 用数据结构$O(\lg n)$地转移.

## 在线
分成$\sqrt n$块. 预处理$f[i][j]$表示块i到块j的众数. 设待查询的区间为$[l, r] = [l, i) \cup [i, j) \cup [j, r]$, $[i, j)$是一些整块, $[l, i)$和$[j, r]$的长度均不超过$\sqrt n$.
$mode [i, j)$已经预处理出来了, 只用将其和$[l, i)$, $[j, r]$中的数作比较.
现在的问题是怎样求一个数$x$在区间$[l, r]$中的出现次数.
### 算法一
可持久化线段树. 每查一次$O(\lg n)$.
### 算法二
对每种数开一个vector, 记录它在整个序列中出现的位置, 二分查找. $O(\lg n)$.
### 算法三
考虑求$x$在$[0, p]$中的出现次数$F(p, x)$.
为了$O(1)$地回答, 需要预处理一些信息.
- $C[i][x]$: 0~i块中x的出现次数. $O(n\sqrt n)$的时空开销.
- $A[i][x]$: 位置i所在块的开头~位置i中x的出现次数. 第一次在某块中遇到某数时给它分配一个id, 将$A[i][id]$作为计数器. $O(n\sqrt n)$的时空开销.
这样, $[0, p]$就可以拆成两部分了.

预处理$f[i][j]$的方法和查询类似. 边扫描边统计每种数的出现次数, 比较$f[i][j-1]$与块$j$中各数的出现次数, 更新$f[i][j]$.
采用算法一, 二, 时间复杂度$O((n+q)\sqrt n\lg n)$, 空间复杂度$O(n)$. 采用算法三, 时间复杂度$O((n+q)\sqrt n)$, 空间复杂度$O(n\sqrt n)$.

# 带修改
先只考虑回答区间众数出现次数. 基本思路是在不带修改的算法上进行扩充.

先看$f$数组. 设把序列分为$L$块, 那么, 一次修改将影响$O(L^2)$对块的$f$值. 现在不能取$L$为$\sqrt n$, 最后来计算合适的值.
对每一对块, 记录每种数的出现次数, 最大出现次数, 出现$i$次的数有多少种. 修改将使得一种数出现次数-1, 一种数出现次数+1, 均使最大出现次数至多变化1, 所以能用$O(1)$的时间修改.

再看$F(p, x)$. 依旧分$\sqrt n$块,
- 块0~i中x的出现次数$C[i][x]$至多有$\sqrt n$个需要修改.
- 位置i所在块开头~位置i的范围内x的出现次数$A[i][x]$也至多有$\sqrt n$个需要修改.

于是, 并不影响总的时间复杂度.

预处理时间$O(nL^2)$ (将$[i, j-1]$的信息复制到$[i, j]$需要$O(n)$), 修改$O(L^2)$, 查询$O(n/L)$, 空间$O(nL^2)$, 取$L = n^{1/3}$, 总的时间复杂度$O((n+q)n^{2/3})$, 空间复杂度$O(n^{5/3})$.

我的脑补: 如果还要回答众数的值, 可以用`set`维护每对块中出现$i$次的数是哪些, 不过时间复杂度好像有点高, 只是理论上优于朴素算法......